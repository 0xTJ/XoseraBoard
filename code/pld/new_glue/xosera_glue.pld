Name     xosera_glue ;
PartNo   00 ;
Date     04/05/2024 [DD/MM/YYYY];
Revision 01 ;
Designer Thomas Jager & Ross Bamford ;
Company  rosco_m68k OSP ;
Assembly None ;
Location  ;
Device   f1508isptqfp100 ;

/*
property   atmel {xor_synthesis=on};
property   atmel {cascade_logic=on};
*/
property   atmel {preassign=keep};
property   atmel {logic_doubling=on};
property   atmel {pin_keep=off};
property   atmel {security=off};
property   atmel {output_fast=on};
property   atmel {tdi_pullup=on};
property   atmel {tms_pullup=on};

/* *************** INPUT PINS *********************/
PIN  40 = SYS_A1;
PIN  41 = SYS_A2;
PIN  42 = SYS_A3;
PIN  44 = !SYS_VPA;
PIN  45 = SYS_A4;
PIN  46 = SYS_A5;
PIN  47 = SYS_A6;
PIN  48 = !SYS_IRQ3;
PIN  49 = SYS_A7;
PIN  50 = !SYS_IOSEL;
PIN  52 = SYS_A8;
PIN  53 = !SYS_EXPSEL;
PIN  54 = SYS_A9;
PIN  55 = SYS_FC0;
PIN  56 = SYS_A10;
PIN  57 = SYS_FC1;
PIN  58 = SYS_A11;
PIN  60 = SYS_FC2;
PIN  61 = SYS_A12;
PIN  63 = !SYS_IRQ5;
PIN  64 = SYS_A13;
PIN  65 = !SYS_IRQ2;
PIN  67 = SYS_A14;
PIN  68 = !SYS_IRQ6;
PIN  69 = SYS_A15;
PIN  70 = !SYS_LDS;
PIN  71 = SYS_A16;
PIN  72 = !SYS_UDS;
PIN  75 = SYS_A17;
PIN  76 = SYS_A18;
PIN  77 = SYS_A19;
PIN  78 = SYS_A20;
PIN  79 = SYS_A21;
PIN  80 = SYS_A22;
PIN  81 = SYS_A23;
PIN  83 = !SYS_AS;
PIN  84 = !SYS_BERR;
PIN  85 = SYS_DTACK;
PIN  87 = SYS_CLK;
PIN  88 = SYS_RnW;
PIN  89 = !SYS_RESET;
PIN  90 = SD_CLK;


/* *************** OUTPUT PINS *********************/
PIN  92 = SD_A4;
PIN  93 = SD_A5;
PIN  94 = SD_A6;
PIN  96 = SD_A7;
PIN  97 = SD_A8;
PIN  98 = SD_A9;
PIN  99 = SD_A11;
PIN 100 = SD_A12;
PIN   1 = SD_CKE;
PIN   2 = SD_DQMH;
PIN   5 = SD_DQML;
PIN   6 = SD_WE;        /* These four are active low,       */
PIN   7 = SD_CAS;       /* but it's easier to match them    */
PIN   8 = SD_RAS;       /* with the datasheet if they're    */
PIN   9 = SD_CS;        /* treated as not so here...        */
PIN  10 = SD_A3;
PIN  12 = SD_A2;
PIN  13 = SD_A1;
PIN  14 = SD_A0;
PIN  16 = SD_A10;
PIN  17 = SD_BA1;
PIN  19 = SD_BA0;
/*
PIN  20 = NC;
PIN  21 = NC;
PIN  22 = NC;
PIN  23 = NC;
PIN  24 = NC;
PIN  25 = NC;
*/
PIN  27 = !XO_CS;
PIN  28 = XO_BYTESEL;
PIN  29 = XO_REG3;
PIN  30 = XO_REG2;
PIN  31 = XO_REG1;
PIN  32 = XO_REG0;
PIN  33 = XO_IRQ;
/*
PIN  35 = NC;
*/
PIN  36 = XO_CRESET;
PIN  37 = XO_CDONE;

NODE  IN_INIT;
NODE  REFRESH_Q;
NODE  RQ4, RQ3, RQ2, RQ1, RQ0;
NODE  SD_DTACK;                         /* Active high! */

FIELD SYS_BANK  = [SYS_FC2, SYS_A23];   /* TODO internal bank reg instead of FC2? */
FIELD SYS_ROW   = [SYS_A22..SYS_A10];
FIELD SYS_COL   = [SYS_A9..SYS_A1];

FIELD SD_BANK   = [SD_BA1, SD_BA0];
FIELD SD_ADDR   = [SD_A12..SD_A0];
FIELD SD_STATE  = [SD_CS, SD_RAS, SD_CAS, SD_WE, SD_DTACK, IN_INIT, SD_CKE];
FIELD SYS_ADDR  = [SYS_A23..SYS_A1];
FIELD RCOUNT    = [RQ4..RQ0];

IN_INIT.sp      = 'b'0;
SD_CKE.sp       = 'b'0;
SD_DTACK.sp     = 'b'0;

SD_STATE.ck     = SD_CLK;
SD_STATE.ar     = !SYS_RESET;

SD_BANK         = SYS_BANK;
SD_DQML         = SYS_LDS;
SD_DQMH         = SYS_UDS;


/** *********************** STATE  DEFINES ******************/
/*                         CRCWDIC  */
/*                         SAAETNK  */
/*                          SS A_E  */
/*                             CI   */
/*                             KN   */
/*                              I   */
/*                              T   */

$define ST_START        'b'0000000  /* Start state               00 */
$define ST_INHIBIT      'b'1000001  /* Inhibit (no CS)           41 */
$define ST_INIT_CKE     'b'0000001  /* Initial CKE               01 */
$define ST_INIT_PC      'b'0010011  /* Initial precharge         13 */
$define ST_REFRESH      'b'0001001  /* Refresh general or init1  09 */
$define ST_RDONE        'b'0111001  /* Refresh done (NOP)        39 */
$define ST_INITR2       'b'0001011  /* 2nd init refr             0B */
$define ST_LOADMODE     'b'0000011  /* Load mode                 03 */
$define ST_ACTIVE       'b'0011001  /* ACTIVATE (row)            19 */
$define ST_READ_CMD     'b'0101001  /* READ (column)             29 */
$define ST_WRITE_CMD    'b'0100001  /* WRITE (column)            21 */
$define ST_ACK          'b'0111101  /* NOP, DTACK                3D */
$define ST_BURST_TERM   'b'0110001  /* We don't use...           31 */
$define ST_PRECHARGE    'b'0010001  /* End cycle                 11 */

/** *********************** SDRAM ADDR BUS ******************/
/* TODO INIT, Load mode reg opcodes                                 */
/* TODO there has to be a better way to do this... tables maybe?    */
/*      I can't find a nice way to conditionally assign fields...   */
CONDITION {
    /* SD A12 */
    IF SD_STATE:ST_ACTIVE       & SYS_A22       OUT SD_A12;

    /* SD A11 */
    IF SD_STATE:ST_ACTIVE       & SYS_A21       OUT SD_A11;
   
    /* SD A10 */
    IF SD_STATE:ST_ACTIVE       & SYS_A20       OUT SD_A10;
    IF SD_STATE:ST_PRECHARGE                    OUT SD_A10;
    IF SD_STATE:ST_INIT_PC                      OUT SD_A10;
   
    /* SD A9 */
    IF SD_STATE:ST_LOADMODE                     OUT SD_A9;      /* Init - Single Loc Write      */
    IF SD_STATE:ST_ACTIVE       & SYS_A19       OUT SD_A9;
   
    /* SD A8 */
    IF SD_STATE:ST_ACTIVE       & SYS_A18       OUT SD_A8;
    IF SD_STATE:ST_READ_CMD     & SYS_A9        OUT SD_A8;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A9        OUT SD_A8;
   
    /* SD A7 */
    IF SD_STATE:ST_ACTIVE       & SYS_A17       OUT SD_A7;
    IF SD_STATE:ST_READ_CMD     & SYS_A8        OUT SD_A7;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A8        OUT SD_A7;
   
    /* SD A6 */
    IF SD_STATE:ST_ACTIVE       & SYS_A16       OUT SD_A6;
    IF SD_STATE:ST_READ_CMD     & SYS_A7        OUT SD_A6;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A7        OUT SD_A6;
   
    /* SD A5 */
    IF SD_STATE:ST_ACTIVE       & SYS_A15       OUT SD_A5;
    IF SD_STATE:ST_READ_CMD     & SYS_A6        OUT SD_A5;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A6        OUT SD_A5;
   
    /* SD A4 */
    IF SD_STATE:ST_LOADMODE                     OUT SD_A4;      /* Init - CAS 001 (1 cycle)     */ 
    IF SD_STATE:ST_ACTIVE       & SYS_A14       OUT SD_A4;
    IF SD_STATE:ST_READ_CMD     & SYS_A5        OUT SD_A4;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A5        OUT SD_A4;
   
    /* SD A3 */
    IF SD_STATE:ST_ACTIVE       & SYS_A13       OUT SD_A3;
    IF SD_STATE:ST_READ_CMD     & SYS_A4        OUT SD_A3;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A4        OUT SD_A3;
   
    /* SD A2 */
    IF SD_STATE:ST_ACTIVE       & SYS_A12       OUT SD_A2;
    IF SD_STATE:ST_READ_CMD     & SYS_A3        OUT SD_A2;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A3        OUT SD_A2;
   
    /* SD A1 */
    IF SD_STATE:ST_ACTIVE       & SYS_A11       OUT SD_A1;
    IF SD_STATE:ST_READ_CMD     & SYS_A2        OUT SD_A1;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A2        OUT SD_A1;
   
    /* SD A0 */
    IF SD_STATE:ST_ACTIVE       & SYS_A10       OUT SD_A0;
    IF SD_STATE:ST_READ_CMD     & SYS_A1        OUT SD_A0;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A1        OUT SD_A0;
}


/** ***********************  SDRAM STATES  ******************/

/* TODO initialization on /RESET... */
SEQUENCE SD_STATE {
    PRESENT ST_START
/*        if SYS_RESET
            NEXT ST_START;*/
        DEFAULT NEXT ST_INIT_CKE;
    PRESENT ST_INIT_CKE
        NEXT ST_INIT_PC;
    PRESENT ST_INIT_PC
        NEXT ST_REFRESH;
    PRESENT ST_REFRESH
        IF REFRESH_Q
            NEXT ST_INHIBIT OUT REFRESH_Q.SR;
        DEFAULT NEXT ST_INITR2;
    PRESENT ST_INITR2
        NEXT ST_LOADMODE;
    PRESENT ST_LOADMODE
        NEXT ST_INHIBIT;
    PRESENT ST_INHIBIT
        if REFRESH_Q
            NEXT ST_PRECHARGE;
        IF !SYS_EXPSEL
            NEXT ST_ACTIVE;
        DEFAULT NEXT ST_INHIBIT;
    PRESENT ST_ACTIVE
        IF SYS_RnW
            NEXT ST_READ_CMD;
        IF !SYS_RnW
            NEXT ST_WRITE_CMD;
    PRESENT ST_READ_CMD
        NEXT ST_ACK;
    PRESENT ST_WRITE_CMD
        NEXT ST_ACK;
    PRESENT ST_ACK
        IF SYS_EXPSEL
            /* TODO could keep row open here and use bursts when poss */
            NEXT ST_PRECHARGE;

        /* waiting for AS to deassert */
        DEFAULT NEXT ST_ACK;
/*
    PRESENT ST_BURST_TERM
        NEXT ST_PRECHARGE;
*/
    PRESENT ST_PRECHARGE
        IF REFRESH_Q
            NEXT ST_REFRESH;
        DEFAULT NEXT ST_INHIBIT;
}


/** ***********************  REFRESH COUNT ******************/
REFRESH_Q.CK    = SD_CLK;
RCOUNT.CK       = SD_CLK;

SEQUENCE RCOUNT {
$repeat i = [0..30]
    PRESENT 'D'{i}
        IF REFRESH_Q OUT REFRESH_Q.D;
        NEXT 'D'{i+1};
$repend
    PRESENT 'D'31
        NEXT 'D'0 OUT REFRESH_Q.D;
}

 
/** ***********************   XOSERA GLUE  ******************/
XO_CS       = SYS_IOSEL & !SYS_UDS & !SYS_LDS & SYS_AS & SYS_ADDR:'b'XXXXXX0000000000011XXXX
            # SYS_IOSEL & !SYS_UDS & !SYS_LDS & SYS_AS & SYS_ADDR:'b'XXXXXX0000000000100XXXX
            ;

SYS_DTACK.SP    = 'b'0;
SYS_DTACK       = 'b'0;
SYS_DTACK.OE    = SYS_RESET & XO_CS & SYS_AS & SYS_LDS
                # SYS_RESET & SD_DTACK
                ;
/*
VPA         = 'b'0;
VPA.OE      = !RESET & AS & RnW & FC0 & FC1 & FC2 & !A1 & A2 & !A3 /* Xosera */
/*
            # !RESET & AS & RnW & FC2 & FC1 & FC0 & !A3 & A2 &  A1 /* IDE    */
/*
            # !RESET & AS & RnW & FC2 & FC1 & FC0 &  A3 & A2 & !A1 /* UART   *
            ;

/*
IRQRS       =          AS & RnW & FC0 & FC1 & FC2 & !A1 &  A2 & !A3 
            # RESET

            ;
*/
