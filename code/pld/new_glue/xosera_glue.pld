Name     xosera_glue ;
PartNo   00 ;
Date     04/05/2024 [DD/MM/YYYY];
Revision 01 ;
Designer Thomas Jager & Ross Bamford ;
Company  rosco_m68k OSP ;
Assembly None ;
Location  ;
Device   f1508isptqfp100 ;

/*
property   atmel {xor_synthesis=on};
property   atmel {cascade_logic=on};
*/
property   atmel {preassign=keep};
property   atmel {logic_doubling=on};
property   atmel {pin_keep=off};
property   atmel {security=off};
property   atmel {output_fast=on};
property   atmel {tdi_pullup=on};
property   atmel {tms_pullup=on};

/* *************** INPUT PINS *********************/
PIN  33 = XO_IRQ;
PIN  35 = XO_DTACK;
PIN  36 = XO_CRESET;
PIN  37 = XO_CDONE;
PIN  40 = SYS_A1;
PIN  41 = SYS_A2;
PIN  42 = SYS_A3;
PIN  44 = SYS_VPA;
PIN  45 = SYS_A4;
PIN  46 = SYS_A5;
PIN  47 = SYS_A6;
PIN  48 = SYS_IRQ3;
PIN  49 = SYS_A7;
PIN  50 = SYS_IOSEL;
PIN  52 = SYS_A8;
PIN  53 = SYS_EXPSEL;
PIN  54 = SYS_A9;
PIN  55 = SYS_FC0;
PIN  56 = SYS_A10;
PIN  57 = SYS_FC1;
PIN  58 = SYS_A11;
PIN  60 = SYS_FC2;
PIN  61 = SYS_A12;
PIN  63 = SYS_IRQ5;
PIN  64 = SYS_A13;
PIN  65 = SYS_IRQ2;
PIN  67 = SYS_A14;
PIN  68 = SYS_IRQ6;
PIN  69 = SYS_A15;
PIN  70 = SYS_LDS;
PIN  71 = SYS_A16;
PIN  72 = SYS_UDS;
PIN  75 = SYS_A17;
PIN  76 = SYS_A18;
PIN  77 = SYS_A19;
PIN  78 = SYS_A20;
PIN  79 = SYS_A21;
PIN  80 = SYS_A22;
PIN  81 = SYS_A23;
PIN  83 = SYS_AS;
PIN  84 = SYS_BERR;
PIN  85 = SYS_DTACK;
PIN  87 = SYS_CLK;
PIN  88 = SYS_RnW;
PIN  89 = SYS_RESET;
PIN  90 = SD_CLK;

/* *************** OUTPUT PINS *********************/
PIN  92 = SD_A4;
PIN  93 = SD_A5;
PIN  94 = SD_A6;
PIN  96 = SD_A7;
PIN  97 = SD_A8;
PIN  98 = SD_A9;
PIN  99 = SD_A11;
PIN 100 = SD_A12;
PIN   1 = SD_CKE;
PIN   2 = SD_DQMH;
PIN   5 = SD_DQML;
PIN   6 = SD_WE;        /* These four are active low,       */
PIN   7 = SD_CAS;       /* but it's easier to match them    */
PIN   8 = SD_RAS;       /* with the datasheet if they're    */
PIN   9 = SD_CS;        /* treated as not so here...        */
PIN  10 = SD_A3;
PIN  12 = SD_A2;
PIN  13 = SD_A1;
PIN  14 = SD_A0;
PIN  16 = SD_A10;
PIN  17 = SD_BA1;
PIN  19 = SD_BA0;
/*
PIN  20 = NC;
PIN  21 = NC;
PIN  22 = NC;
PIN  23 = NC;
PIN  24 = NC;
*/

PIN  25 = XO_RnW;
PIN  27 = XO_CS;
PIN  28 = XO_BYTESEL;
PIN  29 = XO_REG3;
PIN  30 = XO_REG2;
PIN  31 = XO_REG1;
PIN  32 = XO_REG0;

NODE  IN_INIT;
NODE  REFRESH_Q;                        /* Active high! */
NODE  RQ4, RQ3, RQ2, RQ1, RQ0;
NODE  SD_DTACK;                         /* Active high! */
NODE  XO_IRQRQ;                         /* Active high! */
NODE  BANK_FF;

NODE COMMAND_SEL;
NODE CMD_DTACK;                         /* Active high! */
NODE CMDa, CMDb;

FIELD SYS_BANK  = [BANK_FF, SYS_A23];
FIELD SYS_ROW   = [SYS_A22..SYS_A10];
FIELD SYS_COL   = [SYS_A9..SYS_A1];

FIELD SD_BANK   = [SD_BA1, SD_BA0];
FIELD SD_ADDR   = [SD_A12..SD_A0];
FIELD SD_STATE  = [SD_CS, SD_RAS, SD_CAS, SD_WE, SD_DTACK, IN_INIT, SD_CKE];
FIELD SYS_ADDR  = [SYS_A23..SYS_A1];
FIELD RCOUNT    = [RQ4..RQ0];

FIELD COMMAND   = [CMDb, CMDa, CMD_DTACK];

IN_INIT.sp      = 'b'0;
SD_CKE.sp       = 'b'0;
SD_DTACK.sp     = 'b'0;

SD_STATE.ck     = SD_CLK;
SD_STATE.ar     = !SYS_RESET;

SD_BANK         = SYS_BANK;
SD_DQML         = SYS_LDS;
SD_DQMH         = SYS_UDS;

SYS_DTACK.sp    = 'b'0;
SYS_DTACK       = 'b'0;
SYS_DTACK.oe    = /*SYS_RESET & !XO_CS         /* switch XO_CS to XO_DTACK when ready */
                /*#*/ SYS_RESET & SD_DTACK
                # SYS_RESET & CMD_DTACK
                ;

XO_RnW          = SYS_RnW;

/** *********************** STATE  DEFINES ******************/
/* N.B. IN_INIT is quite poorly named, it's just become a   */
/* differentiator for states that would otherside have the  */
/* same decoding...                                         */
/*                                                          */
/*                         CRCWDIC                          */
/*                         SAAETNK                          */
/*                          SS A_E                          */
/*                             CI                           */
/*                             KN                           */
/*                              I                           */
/*                              T                           */
$define ST_START        'b'0000000  /* Start state               00 */
$define ST_INHIBIT      'b'1000001  /* Inhibit (no CS)           41 */
$define ST_INIT_CKE     'b'0000001  /* Initial CKE               01 */
$define ST_INIT_PC      'b'0010011  /* Initial precharge         13 */
$define ST_REFRESH      'b'0001001  /* Refresh general or init1  09 */
$define ST_RDONE        'b'0111001  /* Refresh done (NOP)        39 */
$define ST_INITR2       'b'0001011  /* 2nd init refr             0B */
$define ST_LOADMODE     'b'0000011  /* Load mode                 03 */
$define ST_ACTIVE       'b'0011001  /* ACTIVATE (row)            19 */
$define ST_READ_CMD     'b'0101001  /* READ (column)             29 */
$define ST_WRITE_CMD    'b'0100001  /* WRITE (column)            21 */
$define ST_ACK_DELAY    'b'0111011  /* Delay before ACK (unused) 3B */
$define ST_ACK          'b'0111101  /* NOP, DTACK                3D */
$define ST_BURST_TERM   'b'0110001  /* We don't use...           31 */
$define ST_PRECHARGE    'b'0010001  /* End cycle                 11 */

/** *********************** SDRAM ADDR BUS ******************/
/* TODO there has to be a better way to do this... tables maybe?    */
/*      I can't find a nice way to conditionally assign fields...   */
CONDITION {
    /* SD A12 */
    IF SD_STATE:ST_ACTIVE       & SYS_A22       OUT SD_A12;

    /* SD A11 */
    IF SD_STATE:ST_ACTIVE       & SYS_A21       OUT SD_A11;
   
    /* SD A10 */
    IF SD_STATE:ST_ACTIVE       & SYS_A20       OUT SD_A10;
    IF SD_STATE:ST_PRECHARGE                    OUT SD_A10;
    IF SD_STATE:ST_INIT_PC                      OUT SD_A10;
   
    /* SD A9 */
    IF SD_STATE:ST_LOADMODE                     OUT SD_A9;      /* Init - Single Loc Write      */
    IF SD_STATE:ST_ACTIVE       & SYS_A19       OUT SD_A9;
   
    /* SD A8 */
    IF SD_STATE:ST_ACTIVE       & SYS_A18       OUT SD_A8;
    IF SD_STATE:ST_READ_CMD     & SYS_A9        OUT SD_A8;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A9        OUT SD_A8;
   
    /* SD A7 */
    IF SD_STATE:ST_ACTIVE       & SYS_A17       OUT SD_A7;
    IF SD_STATE:ST_READ_CMD     & SYS_A8        OUT SD_A7;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A8        OUT SD_A7;
   
    /* SD A6 */
    IF SD_STATE:ST_ACTIVE       & SYS_A16       OUT SD_A6;
    IF SD_STATE:ST_READ_CMD     & SYS_A7        OUT SD_A6;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A7        OUT SD_A6;
   
    /* SD A5 */
    IF SD_STATE:ST_LOADMODE                     OUT SD_A5;      /* Init - CAS 010 (2 cycle)     */ 
    IF SD_STATE:ST_ACTIVE       & SYS_A15       OUT SD_A5;
    IF SD_STATE:ST_READ_CMD     & SYS_A6        OUT SD_A5;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A6        OUT SD_A5;
   
    /* SD A4 */
    IF SD_STATE:ST_ACTIVE       & SYS_A14       OUT SD_A4;
    IF SD_STATE:ST_READ_CMD     & SYS_A5        OUT SD_A4;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A5        OUT SD_A4;
   
    /* SD A3 */
    IF SD_STATE:ST_ACTIVE       & SYS_A13       OUT SD_A3;
    IF SD_STATE:ST_READ_CMD     & SYS_A4        OUT SD_A3;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A4        OUT SD_A3;
   
    /* SD A2 */
    IF SD_STATE:ST_ACTIVE       & SYS_A12       OUT SD_A2;
    IF SD_STATE:ST_READ_CMD     & SYS_A3        OUT SD_A2;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A3        OUT SD_A2;
   
    /* SD A1 */
    IF SD_STATE:ST_ACTIVE       & SYS_A11       OUT SD_A1;
    IF SD_STATE:ST_READ_CMD     & SYS_A2        OUT SD_A1;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A2        OUT SD_A1;
   
    /* SD A0 */
    IF SD_STATE:ST_ACTIVE       & SYS_A10       OUT SD_A0;
    IF SD_STATE:ST_READ_CMD     & SYS_A1        OUT SD_A0;
    IF SD_STATE:ST_WRITE_CMD    & SYS_A1        OUT SD_A0;
}


/** ***********************  SDRAM STATES  ******************/

/* TODO initialization on /RESET... */
SEQUENCE SD_STATE {
    PRESENT ST_START
/*        if SYS_RESET
            NEXT ST_START;*/
        DEFAULT NEXT ST_INIT_CKE;
    PRESENT ST_INIT_CKE
        NEXT ST_INIT_PC;
    PRESENT ST_INIT_PC
        NEXT ST_REFRESH;
    PRESENT ST_REFRESH
        IF REFRESH_Q
            NEXT ST_INHIBIT OUT REFRESH_Q.SR;
        DEFAULT NEXT ST_INITR2;
    PRESENT ST_INITR2
        NEXT ST_LOADMODE;
    PRESENT ST_LOADMODE
        NEXT ST_INHIBIT;
    PRESENT ST_INHIBIT
        IF REFRESH_Q
            NEXT ST_PRECHARGE;
        IF !SYS_EXPSEL
            NEXT ST_ACTIVE;
        DEFAULT NEXT ST_INHIBIT;
    PRESENT ST_ACTIVE
        IF SYS_RnW
            NEXT ST_READ_CMD;
        IF !SYS_RnW
            NEXT ST_WRITE_CMD;
    PRESENT ST_READ_CMD
        NEXT ST_ACK;
    PRESENT ST_WRITE_CMD
        NEXT ST_ACK;
    PRESENT ST_ACK
        IF SYS_EXPSEL
            /* TODO could keep row open here and use bursts when poss */
            NEXT ST_PRECHARGE;

        /* waiting for AS to deassert */
        DEFAULT NEXT ST_ACK;
/*
    PRESENT ST_ACK_DELAY
        NEXT ST_ACK;
    PRESENT ST_BURST_TERM
        NEXT ST_PRECHARGE;
*/
    PRESENT ST_PRECHARGE
        IF REFRESH_Q
            NEXT ST_REFRESH;
        DEFAULT NEXT ST_INHIBIT;
}


/** ***********************  REFRESH COUNT ******************/
REFRESH_Q.CK    = SD_CLK;
RCOUNT.CK       = SD_CLK;

SEQUENCE RCOUNT {
$repeat i = [0..30]
    PRESENT 'D'{i}
        IF REFRESH_Q OUT REFRESH_Q.D;
        NEXT 'D'{i+1};
$repend
    PRESENT 'D'31
        NEXT 'D'0 OUT REFRESH_Q.D;
}

 
/** ***********************   XOSERA GLUE  ******************/
/*
!XO_CS      = XO_CDONE & SYS_RESET & !SYS_IOSEL & SYS_UDS  & !SYS_LDS & !SYS_AS & SYS_ADDR:'b'XXXXXX0000000000011XXXXX
            # XO_CDONE & SYS_RESET & !SYS_IOSEL & SYS_UDS  & !SYS_LDS & !SYS_AS & SYS_ADDR:'b'XXXXXX0000000000100XXXXX
            ;

XO_BYTESEL  = SYS_A1;
XO_REG3     = SYS_A7;
XO_REG2     = SYS_A4;
XO_REG1     = SYS_A3;
XO_REG0     = SYS_A2;

SYS_VPA     = 'b'0;
SYS_VPA.oe  = SYS_RESET & !SYS_AS & SYS_RnW & SYS_FC0 & SYS_FC1 & SYS_FC2 & SYS_A19 & !SYS_A1 &  SYS_A2 & !SYS_A3 /* Xosera */
/*
            # SYS_RESET & SYS_AS & SYS_RnW & SYS_FC2 & SYS_FC1 & SYS_FC0 & SYS_A19 &  SYS_A1 &  SYS_A2 & !SYS_A3 /* IDE    */
/*
            # SYS_RESET & SYS_AS & SYS_RnW & SYS_FC2 & SYS_FC1 & SYS_FC0 & SYS_A19 & !SYS_A1 *  SYS_A2 &  SYS_A3 /* UART   */
/*
            ;

XO_IRQRQ.l  = 'b'1;
XO_IRQRQ.ck = XO_IRQ;
XO_IRQRQ.ar = SYS_RESET & !SYS_AS & SYS_RnW & SYS_FC0 & SYS_FC1 & SYS_FC2 & SYS_A19 & !SYS_A1 & SYS_A2 & !SYS_A3;

/*
SYS_IRQ2    = 'b'0;
SYS_IRQ2.oe = XO_IRQRQ;
*/

/** ***********************    REGISTERS   *******************/
/** *********************** COMMAND DEFINES ******************/
$define CMD_BANK_LOW    'b'XXXXXXXXXXXXXXXXXXX0000X
$define CMD_BANK_HIGH   'b'XXXXXXXXXXXXXXXXXXX0001X

/** *********************** COMMAND  STATES ******************/
/*
                             S
                             Y
                             S
                             _
                             D
                             T
                             A
                             C
                           baK                                      */
$define CMD_START       'b'000      /* Start state               00 */
$define CMD_IDLE        'b'010      /* Idle state                02 */
$define CMD_LATCH       'b'100      /* Latch state               04 */
$define CMD_ACK         'b'001      /* ACK command               01 */

/** *********************** OUTPUT  SIGNALS ******************/
BANK_FF.l   = 'b'1;

COMMAND.sp  = 'b'0;
COMMAND.ar  = !SYS_RESET;
COMMAND.ck  = SYS_CLK;

!COMMAND_SEL= SYS_RESET & !SYS_IOSEL & (!SYS_UDS # !SYS_LDS) & !SYS_AS & SYS_ADDR:'b'XXXXXX0000010000011XXXXX;

/** *********************** COMMAND OUTPUTS ******************/
CONDITION {
    IF COMMAND:CMD_LATCH & SYS_ADDR:CMD_BANK_LOW        OUT BANK_FF.ar;
    IF COMMAND:CMD_LATCH & SYS_ADDR:CMD_BANK_HIGH       OUT BANK_FF.ck;
}

/** *********************** COMMAND MACHINE ******************/
SEQUENCE COMMAND {
    PRESENT CMD_START
        NEXT CMD_IDLE;
    PRESENT CMD_IDLE
        IF !COMMAND_SEL
            NEXT CMD_LATCH;
        DEFAULT NEXT CMD_IDLE;
    PRESENT CMD_LATCH
        NEXT CMD_ACK;
    PRESENT CMD_ACK
        IF !SYS_IOSEL
            NEXT CMD_ACK;

        DEFAULT NEXT CMD_IDLE;
}


